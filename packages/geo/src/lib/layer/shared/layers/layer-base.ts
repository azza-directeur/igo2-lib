import { SubjectStatus } from '@igo2/utils';

import BaseLayer from 'ol/layer/Base';

import { BehaviorSubject, Observable, Subject, combineLatest } from 'rxjs';
import { map } from 'rxjs/operators';

import { DataSource } from '../../../datasource/shared/datasources/datasource';
import { MapBase } from '../../../map';
import { getResolutionFromScale } from '../../../map/shared/map.utils';
import { LayerOptions, LayerType } from './layer.interface';

export type AnyLayerBase = LayerBase | LayerGroupBase;

export abstract class LayerBase {
  abstract type: LayerType;
  abstract ol: BaseLayer;
  abstract parent: LayerGroupBase;
  protected abstract createOlLayer(): BaseLayer;

  public collapsed: boolean;
  public firstLoadComponent = true;
  public map: MapBase;
  public olLoadingProblem = false;
  public status$: Subject<SubjectStatus>;
  dataSource: DataSource | undefined;

  /**
   * Define if a layer is generated by code OR defined by layer/context user layer.
   * Useful for filtering layers list in mapOffline.directive or in the sharemap...
   * return false by default.
   */
  get isIgoInternalLayer(): boolean {
    return this.options.isIgoInternalLayer || false;
  }

  get id(): string {
    return String(this.options.id);
  }

  get parentId(): string {
    return this.options.parentId;
  }

  get alias(): string {
    return this.options.alias;
  }

  get title(): string {
    return this.options.title;
  }
  set title(title: string) {
    this.options.title = title;
  }

  get zIndex(): number {
    return this.ol.getZIndex();
  }
  set zIndex(zIndex: number) {
    this.ol.setZIndex(zIndex);
  }

  get baseLayer(): boolean {
    return this.options.baseLayer;
  }
  set baseLayer(baseLayer: boolean) {
    this.options.baseLayer = baseLayer;
  }

  get opacity(): number {
    return this.ol.get('opacity');
  }
  set opacity(opacity: number) {
    this.ol.setOpacity(opacity);
  }

  set isInResolutionsRange(value: boolean) {
    this.isInResolutionsRange$.next(value);
  }
  get isInResolutionsRange(): boolean {
    return this.isInResolutionsRange$.value;
  }
  readonly isInResolutionsRange$ = new BehaviorSubject(false);

  set maxResolution(value: number) {
    this.ol.setMaxResolution(value === 0 ? 0 : value || Infinity);
  }
  get maxResolution(): number {
    return this.ol.getMaxResolution();
  }

  set minResolution(value: number) {
    this.ol.setMinResolution(value || 0);
  }
  get minResolution(): number {
    return this.ol.getMinResolution();
  }

  set visible(value: boolean) {
    this.ol.setVisible(value);
    this._visible$.next(value);
  }
  get visible(): boolean {
    return this._visible$.value;
  }
  private _visible$ = new BehaviorSubject<boolean>(undefined);
  readonly visible$ = this._visible$.asObservable();

  get displayed(): boolean {
    const isVisible = this.parent
      ? this.parent.displayed && this.visible
      : this.visible;
    return isVisible && this.isInResolutionsRange;
  }
  readonly displayed$: Observable<boolean> = combineLatest([
    this.isInResolutionsRange$,
    this.visible$
  ]).pipe(map((bunch: [boolean, boolean]) => bunch[0] && bunch[1]));

  get showInLayerList(): boolean {
    return this.options.showInLayerList !== false;
  }

  get saveableOptions(): Partial<LayerOptions> {
    return {
      title: this.options.title,
      zIndex: this.zIndex,
      visible: this.visible,
      security: this.options.security,
      opacity: this.opacity
    };
  }

  constructor(public options: LayerOptions) {}

  afterCreated(): void {
    if (this.options.zIndex !== undefined) {
      this.zIndex = this.options.zIndex;
    }

    if (this.options.baseLayer && this.options.visible === undefined) {
      this.options.visible = false;
    }

    this.maxResolution =
      this.options.maxResolution ||
      getResolutionFromScale(Number(this.options.maxScaleDenom));
    this.minResolution =
      this.options.minResolution ||
      getResolutionFromScale(Number(this.options.minScaleDenom));

    this.visible =
      this.options.visible === undefined ? true : this.options.visible;
    this.opacity =
      this.options.opacity === undefined ? 1 : this.options.opacity;
  }

  setMap(map: any, parent?: LayerGroupBase) {
    this.map = map;
    this.parent = parent;

    this.parent ? this.parent.addChild(this) : this.map.ol.addLayer(this.ol);
  }

  remove(): void {
    if (!this.map) {
      console.error(`No map for ${this.title}`);
      return;
    }
    this.parent
      ? this.parent.removeChild(this)
      : this.map.ol.removeLayer(this.ol);
  }

  moveTo(parent?: LayerGroupBase): void {
    if (parent == null && this.parent == null) {
      return;
    }

    if (this.parent) {
      if (this.parent.id === parent?.id) {
        return;
      }
    }

    this.remove();
    this.setMap(this.map, parent);
  }
}

export abstract class LayerGroupBase extends LayerBase {
  type: LayerType = 'group';
  children: LayerBase[];

  abstract get descendants(): LayerBase[];

  abstract addChild(layer: LayerBase): void;
  abstract removeChild(layer: LayerBase): void;
  abstract isDescendant(layer: LayerBase): boolean;
}
